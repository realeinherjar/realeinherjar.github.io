---
title: "TabConf 2023 Field Report"
date: 2023-09-02T12:10:10-03:00
draft: true
math: true
---

This is my field report from the 2023 edition of [TabConf](https://tabconf.com),
hosted in Atlanta, USA, from Sep 6th to Sep 9th.
TabConf is a technical, developer-oriented, Bitcoin conference.

In addition to the conference,
I also attended [Base58](https://base58.school)'s
intensive course on [Taproot](https://bitcoinops.org/en/topics/taproot/)
and [Schnorr signatures](https://en.wikipedia.org/wiki/Schnorr_signature).
The course took place in the two days before the conference,
on Sep 4th and Sep 5th.

The design goals of Taproot are:

- Increase privacy
- Reduce the amount of data on-chain
- Use Schnorr

Taproot was activated as a soft fork in November 2021.

## Sep 4th: Base58 Taproot Intensive Course Day 01

Day 01 was really fun.
We had a brief refresher to elliptic curves,
Bitcoin transactions and scripts.

First,
we dived into [Schnorr signatures](https://en.wikipedia.org/wiki/Schnorr_signature),
detailed in [BIP 340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki),
focusing on the commutativity property.
Schnorr signatures are a type of digital signature scheme
that provides security and efficiency advantages
over traditional ECDSA (Elliptic Curve Digital Signature Algorithm) signatures.
They were proposed by the mathematician and cryptographer Claus-Peter Schnorr.
Schnorr signatures improve privacy, scalability, and security.
Due to the commutativity property,
Schnorr signatures can be aggregated,
allowing multiple signatures to be combined into a single signature.
This improves privacy by obscuring the number of participants
in a multi-signature transaction.
The nice thing about Schnorr signatures is that
the sum of private keys is equal to the private key of the sum of public keys.

$$ P = p \cdot G $$

where $G$ is the generator point,
and $p$ is the sum of $n$ private keys,

$$ p = \sum\_{i=1}^{n} p_i $$

and $P$ is the sum of $n$ public keys,

$$ P = \sum\_{i=1}^{n} p_i \cdot G $$

> NOTE: don't forget to $\mod{n}$.

Signature aggregatins depends on a series of rounds of communication,
named as [MuSig2](https://eprint.iacr.org/2020/1261),
and detailed in [BIP 327](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki).
There are tweaks to the internal key,
and also nonce generation and aggregation.
I won't go in to the scope of BIP 327 here,
but I recommend you to read it if you want to know more.

Next, we went over [BIP 342](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki),
that deals with `OP_CHECKSIG` and `OP_CHECKSIGADD`.

`OP_CHECKSIG` is one of the fundamental opcodes in Bitcoin's scripting language.
It is used to check the validity of a digital signature associated
with a specific public key in a transaction input.
When `OP_CHECKSIG` is encountered in a Bitcoin script,
it pops two items from the stack: the first item is the digital signature
(in DER-encoded format),
and the second item is the public key
(compressed or uncompressed) corresponding to the private key used
to create the signature.
It then checks whether the provided signature corresponds to the
provided public key and whether it is a valid signature for the
transaction being spent.
If the signature is valid
`OP_CHECKSIG` pushes `1` onto the stack;
otherwise, it pushes `0`.

`OP_CHECKSIGADD` is an opcode that enhances Bitcoin's scripting capabilities.
It was proposed in [BIP 342](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki),
which also disables `OP_CHECKMULTISIG` and `OP_CHECKMULTISIGVERIFY`.
It is an extension of `OP_CHECKSIG`
and is designed to support Schnorr signature aggregation.
In traditional Bitcoin multisignature transactions,
each signature must be checked individually using multiple `OP_CHECKSIG` operations,
which can be inefficient in terms of script size and verification time.
`OP_CHECKSIGADD` is intended to streamline multisignature verification.
Instead of checking each signature individually,
it allows for the cumulative verification of multiple signatures in a single opcode.
This can significantly reduce the script size
and improve efficiency in cases where multiple signatures need to be checked.

A multisig with Schnorr signatures using Script with `OP_CHECKSIG`
and `OP_CHECKSIGADD` would be:

```text
pubkey1 OP_CHECKSIG pubkey2 OP_CHECKSIGADD pubkey3 OP_CHECKSIGADD OP_2 OP_EQUAL
```

Finally, we discussed Taproot spend and Tapscript execution rules.
Both of these are detailed in [BIP 341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki).
We used the Taproot spending rules to build a Taproot transaction.
Instead of a bunch of conditions that are visible using a Script,
we have a binary tree with merkle roots.

```text
            Root
             |
             |
         /       \
        /         \
       /           \
    Cond 1       Cond 2
                  /  \
                 /    \
             Cond 3   Cond 4
```

The root is a 32-byte hash, and is implicity commited to on-chain.
The conditions are not visible on-chain,
and you structure them as most probable to be used because
you need to commit the hash of all the parents
(intermediate states).

$$ \text{tweak} = \operatorname{taghash}\_{\text{TapTweak}}(P_x \mid\mid root) $$
$$ \text{external key} = \text{internal key} + \text{tweak} $$
$$ Q = P_x + tweak \cdot G $$

where $P_x$ is the x-coordinate of the public key $P$,
$G$ is the generator point,
$\operatorname{taghash}_{\text{TapTweak}}$ is a tag hash function,
using the tag $\text{TapTweak}$,
and $Q$ is the tweaked public key.

The script will be:

```text
script: <version-byte> <data>
   OP_1 <Q_x>
```

where:

- `OP_1` is `0x51`
  (see the [Script page at Bitcoin Wiki](https://en.bitcoin.it/wiki/Script))
  This is the version number of our "segwit script".
  `witness_v1_taproot`:
  - removed two opcodes: `CHECKMULTISIG` and `CHECKMULTISIGVERIFY`
  - introduced a new one: `CHECKSIGADD`
- `Q_x` is the x-coordinate of the (tweaked) public key
  which has 32 bytes, `20` in hex.

Then this script becomes:

```text
51 20 <Q_x>
```

## Sep 5th: Base58 Taproot Intensive Course Day 02

Day 02 built on top of day 01.
First, let's talk about Taproot spending rules.
The way Taproot works is that you have a script that is hidden.
It is just the hash of the root of the binary tree below.
The way you constuct the script is by using a merkle tree,
and hashing all the intermediate states,
i.e. all the leaves and branches below the root node.
The hash is done by concatenating the string representation
of the two things you want to hash and applying SHA256:

```text
hash = SHA256(left || right)
```

> Note: there are some rules to remove ambiguity on which one is the `left` and `right`.

In the following example,
you would hash `Cond 3` with `Cond 4`,
then hash the result with `Cond 1`.
This is the root commitment,
i.e. the root node,
and the thing you publish on-chain.

```text
       Root commitment
       (locking script)
             |
             |
         /       \
        /         \
       /           \
    Cond 1       Cond 2
    (leaf)      (branch)
                  /  \
                 /    \
             Cond 3   Cond 4
             (leaf)   (leaf)
```

We have 3 leaves here: `Cond 1`, `Cond 3` and `Cond 4`,
and 1 branch: `Cond 2`.

The way the spening rules work is that you have to provide a proof-of-inclusion,
which depends on the leaf you want to spend.
So if you want to spend `Cond 3`,
you need to provide the hash of `Cond 4` and `Cond 1`.
Whereas, if you want to spend `Cond 1`,
you just need to provide the hash of `Cond 1` and the hash of the branch `Cond 2`.
Hence, spending conditions that are higher in the tree are cheaper to spend,
because you need to commit less data on-chain.
That is why we structure the tree as most probable to be used on top.

But was more focused on FROST.

## Sep 6th: TabConf Day 01

This is a summary of the talks I attended on the first day of TabConf.

### An Interactive Introduction to Secret Sharing

> <https://github.com/TABConf/2023.tabconf.com/issues/41>

Some fun session about [Lagrange Polynomial](https://en.wikipedia.org/wiki/Lagrange_polynomial)
interpolation and the building blocks behing [Shamir's secret sharing](https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing).
For someone who has a math background and loves math,
that was a really fun session.
However, it was really accessible for anyone.

### Programming Bitcoin in Rust

> <https://github.com/TABConf/2023.tabconf.com/issues/34>

In this workshop we used
[`rust-bitcoin`](https://github.com/rust-bitcoin/rust-bitcoin)
to build and sign a transaction,
both in segwit v0, and taproot.

Here's the original [Workshop repo](https://github.com/tcharding/workshop).
You can see my solution [here](https://github.com/realeinherjar/workshop).

### Building a wallet with BDK 1.0

> <https://github.com/TABConf/2023.tabconf.com/issues/113>

This was a deep-dive into [BDK](https://bitcoindevkit.org/),
by [@notmandatory](https://github.com/notmandatory).
You can find the [code here](https://github.com/notmandatory/tabconf2023-bdk1-workshop).

If you don't know about BDK,
you should definitely check it out.
It is in Rust and very well documented.
I had a very bad experience with BitcoinJS in the past,
I've felt like trying to find something in a dark room.
Whereas with BDK, I've felt like I was in a well lit room.
Everything was well documented and easy to find.

## Sep 7th: TabConf Day 02

This is a summary of the talks I attended on the second day of TabConf.

### Miniscript Discussion

> <https://github.com/TABConf/2023.tabconf.com/issues/51>

This was also a really fun session.
[Miniscript](https://bitcoin.sipa.be/miniscript/)
is a policy language for Bitcoin Script.
It helps you write Bitcoin Script in a more readable way.
It also provides a compiler that can compile your Miniscript policy,
and templates for common operations.

If you want to learn more about Miniscript,
there's the [Bitcoin Miniscript Playground](https://elephant.bitcoindevkit.org/),
and [Minsc](https://min.sc/).

### How do Wallets Work?

> <https://github.com/TABConf/2023.tabconf.com/issues/112>

A nice beginner-friendly session about how wallets work.
This was done by [@craigraw](https://github.com/craigraw) using
[Sparrow wallet](https://sparrowwallet.com/).

### An Interactive Introduction to Zero Knowledge Proofs

> <https://github.com/TABConf/2023.tabconf.com/issues/40>

Another interactive cryptography session.
The topic was [Zero Knowledge Proofs](https://en.wikipedia.org/wiki/Zero-knowledge_proof).

## License

This post is licensed under
[Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International][cc-by-nc-sa].

[![CC BY-SA 4.0][cc-by-nc-sa-image]][cc-by-nc-sa]

[cc-by-nc-sa]: http://creativecommons.org/licenses/by-nc-sa/4.0/
[cc-by-nc-sa-image]: https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png
