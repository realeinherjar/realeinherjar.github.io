<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Taproot Basics | Einherjar</title>
<meta name=keywords content="bitcoin,taproot"><meta name=description content="Warning: This post has KaTeX enabled, so if you want to view the rendered math formulas, you&rsquo;ll have to unfortunately enable JavaScript.
While attending the 2023 edition of TabConf, hosted in Atlanta, USA, from Sep 6th to Sep 9th, I also attended Base58&rsquo;s intensive course on Taproot and Schnorr signatures. The course took place in the two days before the conference, on Sep 4th and Sep 5th.
Here is a very broad overview based on my notes, a bunch of readings and some of my own research."><meta name=author content="Einherjar"><link rel=canonical href=https://realeinherjar.github.io/2023-09-08-taproot/><link crossorigin=anonymous href=/assets/css/stylesheet.857f9fea0402425c5de58e9bd520d541b58a979a2ee014453c6d6b69c2ba3aec.css integrity="sha256-hX+f6gQCQlxd5Y6b1SDVQbWKl5ou4BRFPG1racK6Ouw=" rel="preload stylesheet" as=style><noscript><link crossorigin=anonymous href=/css/includes/noscript.30127fa68e36d08f5dd7f9d4e717dac42e729b844672afd0fbcacb0d9e508595.css integrity="sha256-MBJ/po420I9d1/nU5xfaxC5ym4RGcq/Q+8rLDZ5QhZU=" rel="preload stylesheet" as=style></noscript><link rel=icon href=https://realeinherjar.github.io/assets/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://realeinherjar.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://realeinherjar.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://realeinherjar.github.io/apple-touch-icon.png><link rel=mask-icon href=https://realeinherjar.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:title" content="Taproot Basics"><meta property="og:description" content="Warning: This post has KaTeX enabled, so if you want to view the rendered math formulas, you&rsquo;ll have to unfortunately enable JavaScript.
While attending the 2023 edition of TabConf, hosted in Atlanta, USA, from Sep 6th to Sep 9th, I also attended Base58&rsquo;s intensive course on Taproot and Schnorr signatures. The course took place in the two days before the conference, on Sep 4th and Sep 5th.
Here is a very broad overview based on my notes, a bunch of readings and some of my own research."><meta property="og:type" content="article"><meta property="og:url" content="https://realeinherjar.github.io/2023-09-08-taproot/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-02T12:10:10-03:00"><meta property="article:modified_time" content="2023-10-06T07:38:31-03:00"><meta property="og:site_name" content="Einherjar"><meta name=twitter:card content="summary"><meta name=twitter:title content="Taproot Basics"><meta name=twitter:description content="Warning: This post has KaTeX enabled, so if you want to view the rendered math formulas, you&rsquo;ll have to unfortunately enable JavaScript.
While attending the 2023 edition of TabConf, hosted in Atlanta, USA, from Sep 6th to Sep 9th, I also attended Base58&rsquo;s intensive course on Taproot and Schnorr signatures. The course took place in the two days before the conference, on Sep 4th and Sep 5th.
Here is a very broad overview based on my notes, a bunch of readings and some of my own research."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://realeinherjar.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Taproot Basics","item":"https://realeinherjar.github.io/2023-09-08-taproot/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Taproot Basics","name":"Taproot Basics","description":"Warning: This post has KaTeX enabled, so if you want to view the rendered math formulas, you\u0026rsquo;ll have to unfortunately enable JavaScript.\nWhile attending the 2023 edition of TabConf, hosted in Atlanta, USA, from Sep 6th to Sep 9th, I also attended Base58\u0026rsquo;s intensive course on Taproot and Schnorr signatures. The course took place in the two days before the conference, on Sep 4th and Sep 5th.\nHere is a very broad overview based on my notes, a bunch of readings and some of my own research.","keywords":["bitcoin","taproot"],"articleBody":" Warning: This post has KaTeX enabled, so if you want to view the rendered math formulas, you’ll have to unfortunately enable JavaScript.\nWhile attending the 2023 edition of TabConf, hosted in Atlanta, USA, from Sep 6th to Sep 9th, I also attended Base58’s intensive course on Taproot and Schnorr signatures. The course took place in the two days before the conference, on Sep 4th and Sep 5th.\nHere is a very broad overview based on my notes, a bunch of readings and some of my own research. I am omitting a lot of details here. If you want to learn more, whenever you see a footnote, or a like to a Bitcoin Imporvement Proposal (BIP), go check it out.\nTaproot Design Goals Taproot was activated as a soft fork in November 2021.\nThe design goals of Taproot are:\nIncrease privacy: hide the spending conditions and also hide the fact that you are using a multisig. Reduce the amount of data on-chain: you only need to commit to the root of the tree, and not the leaves. Use Schnorr: Schnorr signatures are more efficient and allow for signature aggregation. Schnorr Signatures Schnorr signatures are a type of digital signature scheme that provides security and efficiency advantages over traditional ECDSA (Elliptic Curve Digital Signature Algorithm) signatures. They were proposed by the mathematician and cryptographer Claus-Peter Schnorr. Schnorr signatures improve privacy, scalability, and security. Due to the commutativity property, Schnorr signatures can be aggregated, allowing multiple signatures to be combined into a single signature. This improves privacy by obscuring the number of participants in a multi-signature transaction. They are detailed in BIP 340. The nice thing about Schnorr signatures is that the sum of private keys is equal to the private key of the sum of public keys. This is what I call “commutativity property”, and allows for signature aggregation1.\nHere’s in a more formal way:\n$$ P = p \\cdot G $$\nwhere $G$ is the generator point2 and $p$ is the sum of $n$ private keys,\n$$ p = \\sum_{i=1}^{n} p_i $$\nand $P$ is the sum of $n$ public keys3:\n$$ P = \\sum_{i=1}^{n} p_i \\cdot G $$\nValidation of Taproot Scripts The validation of Taproot Scripts as detailed in BIP 342, that deals with OP_CHECKSIG and OP_CHECKSIGADD opcodes4. This does Schnorr signature aggregation during the Script execution.\nA 2-of-3 multisig with Schnorr signatures spending Script with OP_CHECKSIG and OP_CHECKSIGADD would be:\npubkey1 OP_CHECKSIG pubkey2 OP_CHECKSIGADD pubkey3 OP_CHECKSIGADD OP_2 OP_EQUAL This would reveal everyone’s public keys on-chain, and also the fact that it is a multisig, with all of the conditions. Additionally, it would be expensive to spend, due to the number of bytes required to commit to the Script on-chain.\nThere are more elegant ways to do this with Taproot Spending Rules and Merkle Trees, which we’ll see next.\nTaproot Merkle Tree Taproot is a series of spending conditions that are defined in a binary tree. Instead of a bunch of conditions that are visible using a Script, we have a binary tree with merkle roots.\nRoot | | / \\ / \\ / \\ Cond 1 Cond 2 / \\ / \\ Cond 3 Cond 4 The root is a hash, and is implicity commited to on-chain. The conditions are not visible on-chain, because you just commit the hash of the root on-chain.\nThe way you build the root is by hashing all the intermediate states5, is by hashing all the leaves and branches below the root node. This is done using a $\\operatorname{hash}(l \\mid\\mid r)$ function, where $l$ is the left node and $r$ is the right node6. The locking script will be:\nscript: where:\nis the version byte. This is the version number of our “segwit script”. is P_x, the x-coordinate of the (tweaked) public key7. Taproot Spending Rules Taproot spending rules are detailed in BIP 341. The way Taproot works is that you have a locking script where all the spending conditions are hidden. This is just the hash of the root of the binary tree below. The way you construct the script is by using a merkle tree, and hashing all the intermediate states, i.e. all the leaves and branches below the root node. The hash is done by concatenating the string representation of the two things you want to hash and applying SHA2566:\nhash = SHA256(left || right) In the following example, you would hash Cond 3 with Cond 4, then hash the result with Cond 1. This is the root commitment, i.e. the root node, and the thing you publish on-chain.\nRoot commitment (locking script) | | / \\ / \\ / \\ Cond 1 Cond 2 (leaf) (branch) / \\ / \\ Cond 3 Cond 4 (leaf) (leaf) We have 3 leaves here: Cond 1, Cond 3 and Cond 4, and 1 branch: Cond 2.\nThe way the spening rules work is that you have to provide a proof-of-inclusion, which depends on the leaf you want to spend. So if you want to spend Cond 3, you need to provide the hash of Cond 4 and Cond 1. Whereas, if you want to spend Cond 1, you just need to provide the hash of Cond 1 and the hash of the branch Cond 2. Hence, spending conditions that are higher in the tree are cheaper to spend, because you need to commit less data on-chain. That is why we structure the tree as most probable to be used on top.\nMuSig2 MuSig2, detailed in BIP 327, is similar to OP_CHECKSIGADD. It allows for signature aggregation in the locking script, and also in the unlocking script. Hence, you can have any multisig with Schnorr signatures, without revealing anything related to the number of participants on-chain, multisig conditions, etc. However, you now need to put all the possible combinations of the pubkeys in the Script. Mind you that this is not a problem, because the resulting aggregate signature will not reveal the underlying individual signatures.\nHere’s a MuSig2 example 2-of-3 threshold, you’ll need 3 spending conditions:\n$$P_1 + P_2$$ $$P_1 + P_3$$ $$P_2 + P_3$$\nwhere $P_n$ is the public key of the $n$-th participant.\nGenerally, for $n$ pubkeys with a threshold of $t$, you need a list of size $\\binom{n}{t}$ for all possible combinations.\nContinuing the example, for every two pairs of pubkeys, aggregate them using elliptic curve cryptography modular algebra, tweak them (if necessary)7, and create a script:\n(P_1 + P_2) OP_CHECKSIG Next, you consruct your Taproot tree listing all the possible spending conditions. (Remember to prioritize by the most plausible spending conditions on top). Calculate the root commitment by hashing all the intermediate states, which are the spending conditions on each leaf or branch, from bottom to top. Pick an internal key and if necessary, tweak7 it to derive an external key. Finally, lock up some bitcoin to the root commitment. That’s it! You have a Taproot tree with MuSig2 that is compact on-chain, and also private. Additionally, you can add more creative spending conditions using Script to the leaves of the tree.\nTo spend it, in your unlocking script, you’ll need to provide a proof-of-inclusion of the spending condition you want to spend, and the aggregated signature to unlock that spending condition.\nLicense This post is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\nSignature aggregations depends on a series of rounds of communication, proposed in MuSig (3 rounds of communication), and superseeded by MuSig2 (which needs 2 rounds of communication, instead of 3) and detailed in BIP 327. There are tweaks to the internal key, and also nonce generation and aggregation. I won’t go in to the scope of BIP 327 here, but I recommend you to read it if you want to know more. ↩︎\nIf you don’t know what a generator point is, check the Wikipedia article on Elliptic Curve Cryptography. ↩︎\nDon’t forget to $\\mod{n}$. ↩︎\nSee the Script page at Bitcoin Wiki. ↩︎\nAdditionally you need to provide a tag, which are detailed in BIP 340. ↩︎\nThere are some rules to remove ambiguity on which one will be the left and right node in the hash function. ↩︎ ↩︎\nIn Taproot Spending rules, you can have an internal key and an external key. The internal key is tweaked with “tag” hashes to derive the external key. Check BIP 341. ↩︎ ↩︎ ↩︎\n","wordCount":"1382","inLanguage":"en","datePublished":"2023-09-02T12:10:10-03:00","dateModified":"2023-10-06T07:38:31-03:00","author":{"@type":"Person","name":"Einherjar"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://realeinherjar.github.io/2023-09-08-taproot/"},"publisher":{"@type":"Organization","name":"Einherjar","logo":{"@type":"ImageObject","url":"https://realeinherjar.github.io/assets/favicon.ico"}}}</script></head><body class=dark id=top><script crossorigin=anonymous src=/assets/js/theme.b20f95bb4da41ef90a2610a557a7000b2649a3f47282ec571676da6fc0427200.js integrity="sha256-sg+Vu02kHvkKJhClV6cACyZJo/RyguxXFnbab8BCcgA="></script><header class=header><div id=progressBar></div><nav class=nav><div class=logo><a href=https://realeinherjar.github.io/ accesskey=h title="Einherjar (Alt + H)">Einherjar</a><div class=logo-switches><button type=button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><input name=hamburger-input id=hamburger-input type=checkbox aria-label="Navigation Menu">
<label id=hamburger-menu for=hamburger-input></label><div class=overlay></div><ul id=menu><li><a href=https://realeinherjar.github.io/about title=About><span>About</span></a></li><li><a href=https://realeinherjar.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://realeinherjar.github.io/privacy/ title="Privacy Basics"><span>Privacy Basics</span></a></li><li><a href=https://realeinherjar.github.io/categories/bitcoin-basics title="Bitcoin Basics"><span>Bitcoin Basics</span></a></li><li><a href=https://realeinherjar.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://realeinherjar.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://realeinherjar.github.io/posts/>Blog</a></div><h1 class=post-title>Taproot Basics</h1><div class=post-meta>&lt;span title='2023-09-02 12:10:10 -0300 -0300'>September 2, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;7 min&amp;nbsp;·&amp;nbsp;Einherjar&nbsp;|&nbsp;<a href=https://github.com/realeinherjar/realeinherjar.github.io/blob/main/content/posts/2023-09-08-taproot.md rel="noopener noreferrer">Source code</a></div><div class=post-meta><span title="2023-10-06 07:38:31 -0300 -0300"><i>Last updated on October 6, 2023</i></span></div></header><div class="toc side"><details id=toc><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#taproot-design-goals aria-label="Taproot Design Goals">Taproot Design Goals</a></li><li><a href=#schnorr-signatures aria-label="Schnorr Signatures">Schnorr Signatures</a></li><li><a href=#validation-of-taproot-scripts aria-label="Validation of Taproot Scripts">Validation of Taproot Scripts</a></li><li><a href=#taproot-merkle-tree aria-label="Taproot Merkle Tree">Taproot Merkle Tree</a></li><li><a href=#taproot-spending-rules aria-label="Taproot Spending Rules">Taproot Spending Rules</a></li><li><a href=#musig2 aria-label=MuSig2>MuSig2</a></li><li><a href=#license aria-label=License>License</a></li></ul></div></details></div><div class=post-content><blockquote><p>Warning: This post has <a href=https://katex.org/>KaTeX</a> enabled,
so if you want to view the rendered math formulas,
you&rsquo;ll have to unfortunately enable JavaScript.</p></blockquote><p>While attending the 2023 edition of <a href=https://tabconf.com>TabConf</a>,
hosted in Atlanta, USA, from Sep 6th to Sep 9th,
I also attended <a href=https://base58.school>Base58</a>&rsquo;s
intensive course on <a href=https://bitcoinops.org/en/topics/taproot/>Taproot</a>
and <a href=https://en.wikipedia.org/wiki/Schnorr_signature>Schnorr signatures</a>.
The course took place in the two days before the conference,
on Sep 4th and Sep 5th.</p><p>Here is a very broad overview based on my notes,
a bunch of readings and some of my own research.
I am omitting a lot of details here.
If you want to learn more,
whenever you see a footnote,
or a like to a Bitcoin Imporvement Proposal (BIP),
go check it out.</p><h2 id=taproot-design-goals>Taproot Design Goals<a hidden class=anchor aria-hidden=true href=#taproot-design-goals>#</a></h2><p>Taproot was activated as a soft fork in <strong>November 2021</strong>.</p><p>The <strong>design goals of Taproot</strong> are:</p><ul><li><strong>Increase privacy</strong>: hide the spending conditions
and also hide the fact that you are using a multisig.</li><li><strong>Reduce the amount of data on-chain</strong>: you only need to commit
to the root of the tree, and not the leaves.</li><li><strong>Use Schnorr</strong>: Schnorr signatures are more efficient
and allow for signature aggregation.</li></ul><h2 id=schnorr-signatures>Schnorr Signatures<a hidden class=anchor aria-hidden=true href=#schnorr-signatures>#</a></h2><p><a href=https://en.wikipedia.org/wiki/Schnorr_signature><strong>Schnorr signatures</strong></a>
are a type of digital signature scheme
that provides security and efficiency advantages
over traditional ECDSA (Elliptic Curve Digital Signature Algorithm) signatures.
They were proposed by the mathematician and cryptographer <a href=https://en.wikipedia.org/wiki/Claus_P._Schnorr>Claus-Peter Schnorr</a>.
Schnorr signatures improve privacy, scalability, and security.
Due to the commutativity property,
Schnorr signatures can be aggregated,
allowing multiple signatures to be combined into a single signature.
This improves privacy by <strong>obscuring the number of participants
in a multi-signature transaction</strong>.
They are detailed in <a href=https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>BIP 340</a>.
The nice thing about Schnorr signatures is that
the <strong>sum of private keys is equal to the private key of the sum of public keys</strong>.
This is what I call <strong>&ldquo;commutativity property&rdquo;</strong>,
and allows for <strong>signature aggregation</strong><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>Here&rsquo;s in a more formal way:</p><p>$$ P = p \cdot G $$</p><p>where $G$ is the generator point<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>
and $p$ is the sum of $n$ private keys,</p><p>$$ p = \sum_{i=1}^{n} p_i $$</p><p>and $P$ is the sum of $n$ public keys<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>:</p><p>$$ P = \sum_{i=1}^{n} p_i \cdot G $$</p><h2 id=validation-of-taproot-scripts>Validation of Taproot Scripts<a hidden class=anchor aria-hidden=true href=#validation-of-taproot-scripts>#</a></h2><p>The validation of Taproot Scripts as detailed in
<a href=https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki>BIP 342</a>,
that deals with <code>OP_CHECKSIG</code> and <code>OP_CHECKSIGADD</code> opcodes<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.
This does Schnorr signature aggregation during the Script execution.</p><p>A 2-of-3 multisig with Schnorr signatures spending Script with <code>OP_CHECKSIG</code>
and <code>OP_CHECKSIGADD</code> would be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>pubkey1 OP_CHECKSIG pubkey2 OP_CHECKSIGADD pubkey3 OP_CHECKSIGADD OP_2 OP_EQUAL
</span></span></code></pre></div><p>This would reveal everyone&rsquo;s public keys on-chain,
and also the fact that it is a multisig, with all of the conditions.
Additionally, it would be expensive to spend,
due to the number of bytes required to commit to the Script on-chain.</p><p>There are more elegant ways to do this with Taproot Spending Rules
and Merkle Trees, which we&rsquo;ll see next.</p><h2 id=taproot-merkle-tree>Taproot Merkle Tree<a hidden class=anchor aria-hidden=true href=#taproot-merkle-tree>#</a></h2><p>Taproot is a series of spending conditions that are defined
in a binary tree.
Instead of a bunch of conditions that are visible using a Script,
we have a binary tree with merkle roots.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>            Root
</span></span><span class=line><span class=cl>             |
</span></span><span class=line><span class=cl>             |
</span></span><span class=line><span class=cl>         /       \
</span></span><span class=line><span class=cl>        /         \
</span></span><span class=line><span class=cl>       /           \
</span></span><span class=line><span class=cl>    Cond 1       Cond 2
</span></span><span class=line><span class=cl>                  /  \
</span></span><span class=line><span class=cl>                 /    \
</span></span><span class=line><span class=cl>             Cond 3   Cond 4
</span></span></code></pre></div><p>The root is a hash, and is implicity commited to on-chain.
The conditions are not visible on-chain,
because you just commit the hash of the root on-chain.</p><p>The way you build the root is by hashing all the intermediate states<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>,
is by hashing all the leaves and branches below the root node.
This is done using a $\operatorname{hash}(l \mid\mid r)$ function,
where $l$ is the left node and $r$ is the right node<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>.
The locking script will be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>script: &lt;version-byte&gt; &lt;data&gt;
</span></span></code></pre></div><p>where:</p><ul><li><code>&lt;version-byte></code> is the version byte.
This is the version number of our &ldquo;segwit script&rdquo;.</li><li><code>&lt;data></code> is <code>P_x</code>, the x-coordinate of the (tweaked) public key<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>.</li></ul><h2 id=taproot-spending-rules>Taproot Spending Rules<a hidden class=anchor aria-hidden=true href=#taproot-spending-rules>#</a></h2><p>Taproot spending rules are detailed in <a href=https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki>BIP 341</a>.
The way Taproot works is that you have a locking script
where all the spending conditions are hidden.
This is just the hash of the root of the binary tree below.
The way you construct the script is by using a merkle tree,
and hashing all the intermediate states,
i.e. all the leaves and branches below the root node.
The hash is done by concatenating the string representation
of the two things you want to hash and applying SHA256<sup id=fnref1:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>hash = SHA256(left || right)
</span></span></code></pre></div><p>In the following example,
you would hash <code>Cond 3</code> with <code>Cond 4</code>,
then hash the result with <code>Cond 1</code>.
This is the root commitment,
i.e. the root node,
and the thing you publish on-chain.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>       Root commitment
</span></span><span class=line><span class=cl>       (locking script)
</span></span><span class=line><span class=cl>             |
</span></span><span class=line><span class=cl>             |
</span></span><span class=line><span class=cl>         /       \
</span></span><span class=line><span class=cl>        /         \
</span></span><span class=line><span class=cl>       /           \
</span></span><span class=line><span class=cl>    Cond 1       Cond 2
</span></span><span class=line><span class=cl>    (leaf)      (branch)
</span></span><span class=line><span class=cl>                  /  \
</span></span><span class=line><span class=cl>                 /    \
</span></span><span class=line><span class=cl>             Cond 3   Cond 4
</span></span><span class=line><span class=cl>             (leaf)   (leaf)
</span></span></code></pre></div><p>We have 3 leaves here: <code>Cond 1</code>, <code>Cond 3</code> and <code>Cond 4</code>,
and 1 branch: <code>Cond 2</code>.</p><p>The way the spening rules work is that you have to provide a proof-of-inclusion,
which depends on the leaf you want to spend.
So if you want to spend <code>Cond 3</code>,
you need to provide the hash of <code>Cond 4</code> and <code>Cond 1</code>.
Whereas, if you want to spend <code>Cond 1</code>,
you just need to provide the hash of <code>Cond 1</code> and the hash of the branch <code>Cond 2</code>.
Hence, spending conditions that are higher in the tree are cheaper to spend,
because you need to commit less data on-chain.
That is why we structure the tree as most probable to be used on top.</p><h2 id=musig2>MuSig2<a hidden class=anchor aria-hidden=true href=#musig2>#</a></h2><p><a href=https://eprint.iacr.org/2020/1261>MuSig2</a>,
detailed in <a href=https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki>BIP 327</a>,
is similar to <code>OP_CHECKSIGADD</code>.
It allows for signature aggregation in the locking script,
and also in the unlocking script.
Hence, you can have any multisig with Schnorr signatures,
without revealing anything related to the number of participants on-chain,
multisig conditions, etc.
However,
you now need to put all the possible combinations of the pubkeys in the Script.
Mind you that this is not a problem,
because the resulting aggregate signature
will not reveal the underlying individual signatures.</p><p>Here&rsquo;s a MuSig2 example 2-of-3 threshold,
you&rsquo;ll need 3 spending conditions:</p><p>$$P_1 + P_2$$
$$P_1 + P_3$$
$$P_2 + P_3$$</p><p>where $P_n$ is the public key of the $n$-th participant.</p><p>Generally, for $n$ pubkeys with a threshold of $t$,
you need a list of size $\binom{n}{t}$ for all possible combinations.</p><p>Continuing the example,
for every two pairs of pubkeys,
aggregate them using elliptic curve cryptography modular algebra,
tweak them (if necessary)<sup id=fnref1:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>,
and create a script:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(P_1 + P_2) OP_CHECKSIG
</span></span></code></pre></div><p>Next, you consruct your Taproot tree listing all the possible spending conditions.
(Remember to prioritize by the most plausible spending conditions on top).
Calculate the root commitment by hashing all the intermediate states,
which are the spending conditions on each leaf or branch,
from bottom to top.
Pick an internal key
and if necessary, tweak<sup id=fnref2:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup> it to derive an external key.
Finally, lock up some bitcoin to the root commitment.
That&rsquo;s it!
You have a Taproot tree with MuSig2 that is compact on-chain,
and also private.
Additionally, you can add more creative spending conditions using Script
to the leaves of the tree.</p><p>To spend it, in your unlocking script,
you&rsquo;ll need to provide a proof-of-inclusion
of the spending condition you want to spend,
and the aggregated signature to unlock that spending condition.</p><h2 id=license>License<a hidden class=anchor aria-hidden=true href=#license>#</a></h2><p>This post is licensed under
<a href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International</a>.</p><p><a href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img loading=lazy src=https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png alt="CC BY-NC-SA 4.0"></a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Signature aggregations depends on a series of rounds of communication,
proposed in <a href=https://eprint.iacr.org/2018/068.pdf><strong>MuSig</strong></a>
(3 rounds of communication),
and superseeded by
<a href=https://eprint.iacr.org/2020/1261><strong>MuSig2</strong></a>
(which needs 2 rounds of communication, instead of 3)
and detailed in <a href=https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki>BIP 327</a>.
There are tweaks to the internal key,
and also nonce generation and aggregation.
I won&rsquo;t go in to the scope of BIP 327 here,
but I recommend you to read it if you want to know more.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>If you don&rsquo;t know what a generator point is,
check the <a href=https://en.wikipedia.org/wiki/Elliptic-curve_cryptography#Domain_parameters>Wikipedia article on Elliptic Curve Cryptography</a>.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Don&rsquo;t forget to $\mod{n}$.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>See the <a href=https://en.bitcoin.it/wiki/Script>Script page at Bitcoin Wiki</a>.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>Additionally you need to provide a tag,
which are detailed in <a href=https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>BIP 340</a>.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>There are some rules to remove ambiguity
on which one will be the <code>left</code> and <code>right</code> node in the hash function.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>In Taproot Spending rules,
you can have an internal key and an external key.
The internal key is tweaked with &ldquo;tag&rdquo; hashes to derive the external key.
Check <a href=https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki>BIP 341</a>.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://realeinherjar.github.io/tags/bitcoin/>bitcoin</a></li><li><a href=https://realeinherjar.github.io/tags/taproot/>taproot</a></li></ul><nav class=paginav><a class=prev href=https://realeinherjar.github.io/privacy/><span class=title>« Prev</span><br><span>Privacy Basics</span>
</a><a class=next href=https://realeinherjar.github.io/2023-10-08-elliptic_curves/><span class=title>Next »</span><br><span>What the hell is an Elliptic Curve?</span></a></nav></footer></article></main><footer class=footer><span><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>- Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer">Hugo</a> &
        <a href=https://github.com/Wonderfall/hugo-WonderMod/ rel=noopener>WonderMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script defer crossorigin=anonymous src=/assets/js/papermod.7ea300eda6d3653624a576fbc095ccd8a0c2977756acbe5de4114132a72cc7fa.js integrity="sha256-fqMA7abTZTYkpXb7wJXM2KDCl3dWrL5d5BFBMqcsx/o="></script></body></html>